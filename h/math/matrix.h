#ifndef __COOLWORK_MATHLIB_MATRIX__
#define __COOLWORK_MATHLIB_MATRIX__

#pragma pack(push,1)

/////////////////////////////////////////////////////////////////////////////////////////////
///Матрица
/////////////////////////////////////////////////////////////////////////////////////////////
template <class type,int size>
class matrix
{
  public:
    typedef vec<type,size> vector;    //вектор строка

////////////////////////////////////////////////////////////////////////////////////////////
///Конструктор
////////////////////////////////////////////////////////////////////////////////////////////
    matrix () {}
    matrix (const type& a);  //a будет записано на главной диагонали
    matrix (const type*);                                            
    matrix (const quat<type>&);   //только для матриц 3-го и 4-го порядка

      //для использования оптимизации возвращаемого значения
    template <class T1>           matrix (const T1&,void (*eval)(matrix&,const T1&));
    template <class T1,class T2>  matrix (const T1&,const T2&,void (*eval)(matrix&,const T1&,const T2&));

////////////////////////////////////////////////////////////////////////////////////////////
///Индексирование
////////////////////////////////////////////////////////////////////////////////////////////
          vector& row     (int i);
    const vector& row     (int i) const;
    const vector  column  (int i) const; //копия!

    operator vector*       ()       { return x; }
    operator const vector* () const { return x; }

////////////////////////////////////////////////////////////////////////////////////////////
///Унарные операции
////////////////////////////////////////////////////////////////////////////////////////////
    const matrix&  operator +  () const;
    const matrix   operator -  () const;

////////////////////////////////////////////////////////////////////////////////////////////
///Присваивание
////////////////////////////////////////////////////////////////////////////////////////////
    matrix&  operator = (const quat<type>&);  //только для матриц 3-го и 4-го порядка
    matrix&  operator = (const type&);

////////////////////////////////////////////////////////////////////////////////////////////
///Основные арифметические операции
////////////////////////////////////////////////////////////////////////////////////////////
    matrix&      operator += (const matrix&);
    matrix&      operator -= (const matrix&);
    matrix&      operator *= (const type&);
    matrix&      operator /= (const type&);
    matrix&      operator *= (const matrix&);

    const matrix operator +  (const matrix&) const;
    const matrix operator -  (const matrix&) const;
    const matrix operator *  (const type&) const;
    const matrix operator /  (const type&) const; 
    const matrix operator *  (const matrix&) const; 

    friend const matrix operator * (const type& a,const matrix& m) { return m*a; }

////////////////////////////////////////////////////////////////////////////////////////////
///Умножение на вектор (матрица строка - вектор столбец)
////////////////////////////////////////////////////////////////////////////////////////////
    const vec<type,size>   operator * (const vec<type,size>&) const;
    const vec<type,size-1> operator * (const vec<type,size-1>&) const;

////////////////////////////////////////////////////////////////////////////////////////////
///Отношения между матрицами
////////////////////////////////////////////////////////////////////////////////////////////
    bool operator == (const matrix&) const;
    bool operator != (const matrix&) const;             

////////////////////////////////////////////////////////////////////////////////////////////
///Транспонирование / инвертирование / нормализация матрицы
////////////////////////////////////////////////////////////////////////////////////////////
    void  transpose ();
    void  invert    ();
    void  normalize ();

  private:
    vector x [size];  
};

#pragma pack(pop)

////////////////////////////////////////////////////////////////////////////////////////////
///Утилиты
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
///Взятие транспонированнной матрицы 
////////////////////////////////////////////////////////////////////////////////////////////
template <class type,int size>
matrix<type,size> transpose (const matrix<type,size>&);

////////////////////////////////////////////////////////////////////////////////////////////
///Взятие обратной матрицы
////////////////////////////////////////////////////////////////////////////////////////////
template <class type,int size>
matrix<type,size> invert (const matrix<type,size>&);

////////////////////////////////////////////////////////////////////////////////////////////
///Взятие нормированной матрицы
////////////////////////////////////////////////////////////////////////////////////////////
template <class type,int size>
matrix<type,size> normalize (const matrix<type,size>&);

////////////////////////////////////////////////////////////////////////////////////////////
///Определитель (для квадратной матрицы)
////////////////////////////////////////////////////////////////////////////////////////////
template <class type,int size> 
type det (const matrix<type,size>&);

////////////////////////////////////////////////////////////////////////////////////////////
///Минор
////////////////////////////////////////////////////////////////////////////////////////////
template <class type,int size>
type minor (const matrix<type,size>&,int,int);

////////////////////////////////////////////////////////////////////////////////////////////
///Сравнение матриц
////////////////////////////////////////////////////////////////////////////////////////////
template <class type,int size> 
bool equal (const matrix<type,size>&,const matrix<type,size>&,const type& eps);

#endif
