#ifndef __COOLWORK_ETC__
#define __COOLWORK_ETC__

#include <stddef.h>
#include <mathlib.h>

class Var;
class Expression;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Описание настроек
///////////////////////////////////////////////////////////////////////////////////////////////////
class Etc
{
  friend class Var;
  friend class Expression;
  public:    
    Etc ();
    ~Etc ();

    Etc& operator = (const Etc&);
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление переменной / очистка пула
///////////////////////////////////////////////////////////////////////////////////////////////////      
    void remove (const char*);  
    void clear  ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Биндинг переменных (переменные создаются автоматически)
///////////////////////////////////////////////////////////////////////////////////////////////////  
    void bind (const char* var_name,int&);
    void bind (const char* var_name,float&);
    void bind (const char* var_name,vec3f&);
    void bind (const char* var_name,char* buf,size_t max_size=-1);
    
    typedef void (*OnUpdateHandler)(Var&);    
    
    void bind_handler (const char* var_name,OnUpdateHandler on_set,OnUpdateHandler on_get);
    
    template <class T>
    void bind_handler (const char* var_name,T& obj,void (T::*on_set)(Var&),void (T::*on_get)(Var&));
    
    void unbind (const char* name); //no remove    
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поиск переменной
///////////////////////////////////////////////////////////////////////////////////////////////////          
    Var* find (const char* name);
    bool present (const char*);    
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Изменение / чтение переменной (при изменении отсутствующая переменная создаётся автоматически)
///////////////////////////////////////////////////////////////////////////////////////////////////      
    void set (const char* name,const char* value);
    void set (const char* name,int value);
    void set (const char* name,float value);
    void set (const char* name,const vec3f& value);    
    
    const char* gets  (const char* name);
    int         geti  (const char* name);
    float       getf  (const char* name);
    vec3f       get3f (const char* name);    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с выражениями
///////////////////////////////////////////////////////////////////////////////////////////////////                      
    void        set_expression (const char* name,const char* expression);
    const char* get_expression (const char* name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Принудительное обновление переменной
///////////////////////////////////////////////////////////////////////////////////////////////////              
    void update       (const char* var_name);    
    void group_update (const char* mask);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Дамп переменных (для отладки)
///////////////////////////////////////////////////////////////////////////////////////////////////          
    void dump (const char* mask);
    
  private:
    Var* find_or_create (const char*);
    
    vec3f solve (Expression*);
    
    void add_dep    (const char* var_name,const char* dependency_name);
    void remove_dep (const char* var_name,const char* dependency_name);    
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Переменная
///////////////////////////////////////////////////////////////////////////////////////////////////
class Var
{
  friend class  Etc;
  friend struct Etc::Impl;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя переменной / окружение
///////////////////////////////////////////////////////////////////////////////////////////////////      
    const char* name ();
    Etc&        etc  ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Чтение переменной
///////////////////////////////////////////////////////////////////////////////////////////////////    
    const char* gets  ();
    int         geti  ();
    float       getf  ();
    vec3f       get3f ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка переменной
///////////////////////////////////////////////////////////////////////////////////////////////////
    void set (const char* value);
    void set (int value);
    void set (float value);
    void set (const vec3f& value);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Функции обновления переменной
///////////////////////////////////////////////////////////////////////////////////////////////////
    typedef void (*OnUpdateHandler)(Var&);

    void bind (char* buf,size_t buf_size=-1);
    void bind (int&);
    void bind (float&);
    void bind (vec3f&);    
    
    void bind_handler (OnUpdateHandler onSet,OnUpdateHandler onGet);
    
    template <class T>
    void bind_handler (T& obj,void (T::*on_set_fn)(Var&),void (T::*on_get_fn)(Var&));    
    
    void unbind ();   
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с выражениями
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void        set_expression (const char* expression);
    const char* get_expression ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Принудительное обновление переменной
///////////////////////////////////////////////////////////////////////////////////////////////////        
    void update ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Отладочный вывод переменной
///////////////////////////////////////////////////////////////////////////////////////////////////            
    void dump ();    
    
  private:
    Var (Etc& etc,const char* name);
    ~Var ();
    
    Var& operator = (const Var&);
    
    void _bind_handler (void* obj,void* onSet,void* onGet);    

  private:
    struct Impl;
    Impl* impl;
};

template <class T>
inline void Var::bind_handler (T& obj,void (T::*on_set_fn)(Var&),void (T::*on_get_fn)(Var&))
{
  union Dummy { 
    void (T::*on_update)(Var&);
    void* dummy;
  };
  
  Dummy on_set = {on_set_fn}, on_get = {on_get_fn};

  _bind_handler (&obj,on_set.dummy,on_get.dummy);
}

template <class T>
inline void Etc::bind_handler (const char* name,T& obj,void (T::*on_set_fn)(Var&),void (T::*on_get_fn)(Var&))
{
  if (!name)
    return;

  find_or_create (name)->bind_handler (obj,on_set_fn,on_get_fn);    
}

#endif
