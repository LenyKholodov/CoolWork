#ifndef __COOLWORK_SCENE__
#define __COOLWORK_SCENE__

#include <stddef.h>
#include <mathlib.h>
#include <cmd.h>
#include <mesh.h>
#include <landscape.h>

//forwards
class Entity;
class EntityList;
class Light;
class Camera;
class ParamModel;
class HelperEntity;
class LandscapeModel;
class Scene;
class SceneVisitor;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Метод обхода
///////////////////////////////////////////////////////////////////////////////////////////////////        
enum Traverse
{
  TRAVERSE_TOP_TO_BOTTOM, //обход объектов от корня к потомкам
  TRAVERSE_BOTTOM_TO_TOP, //обход объектов от потомков к корню
  TRAVERSE_NO_RECURSION   //посещение только указанного объекта
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Класс для обхода дерева объектов
///////////////////////////////////////////////////////////////////////////////////////////////////        
class EntityVisitor
{
  public:
    virtual void visit (Entity*) {}
    virtual void visit (Light*) {}
    virtual void visit (Camera*)  {}
    virtual void visit (ParamModel*) {}
    virtual void visit (HelperEntity*) {}
    virtual void visit (LandscapeModel*) {}    
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Список объектов
///////////////////////////////////////////////////////////////////////////////////////////////////        
class EntityList
{
  public:
    EntityList  ();
    EntityList  (const EntityList&);    
    ~EntityList ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Перебор объектов списка
///////////////////////////////////////////////////////////////////////////////////////////////////            
    size_t  size () const;
    Entity* item (size_t index) const;
    bool    test (Entity*) const;
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Добавление/удаление объектов
///////////////////////////////////////////////////////////////////////////////////////////////////          
    void insert (Entity*);
    void remove (Entity*);
    void clear  ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Обход объектов списка
///////////////////////////////////////////////////////////////////////////////////////////////////
    void traverse (EntityVisitor*,Traverse = TRAVERSE_NO_RECURSION);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Копирование
///////////////////////////////////////////////////////////////////////////////////////////////////        
    EntityList& operator = (const EntityList&);
      
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Флаги объекта
///////////////////////////////////////////////////////////////////////////////////////////////////
enum EntityFlags
{
  ENTITY_VISIBLE = 1, //объект видимый    
  ENTITY_SELECT  = 2, //объект выделен
  ENTITY_TEMP    = 4, //временный объект - не сохраняется при сериализации
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Метод выделения
///////////////////////////////////////////////////////////////////////////////////////////////////
enum EntitySelect
{
  ENTITY_GROUP_SELECT,     //групповое выделение
  ENTITY_EXCLUSIVE_SELECT, //исключающее выделение (только один объект)
  ENTITY_CLEAR_SELECT,     //очистить выделение
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовый объект сцены
///////////////////////////////////////////////////////////////////////////////////////////////////
class Entity
{
  friend class Scene;
  public:   
///////////////////////////////////////////////////////////////////////////////////////////////////
///Подсчёт ссылок
///////////////////////////////////////////////////////////////////////////////////////////////////      
    void addref  ();
    void release ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Удаление объекта
///////////////////////////////////////////////////////////////////////////////////////////////////          
    void destroy ();    
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Имя
///////////////////////////////////////////////////////////////////////////////////////////////////
    void        rename (const char* name);
    const char* name   ();
    Entity*     find   (const char* name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Флаги
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void enable    (size_t flags);
    void disable   (size_t flags);
    bool IsEnabled (size_t flags);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сцена, которой принадлежит объект
///////////////////////////////////////////////////////////////////////////////////////////////////        
    Scene* scene ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с иерархией
///////////////////////////////////////////////////////////////////////////////////////////////////
    void bind   (Entity* parent,bool save_world_pos=false); //линковка ообъекта к родиьтелю
    void unbind (bool save_world_pos=false);                //перелинковка к корневому узлу

    Entity* parent (); //родительский объект
    Entity* first  (); //первый ребёнок
    Entity* last   (); //последний ребёнок
    Entity* next   (); //следуюющий ребёнок
    Entity* prev   (); //предыдущий ребёнок
    
    size_t GetNodeDepth (); //возвращает глубину узла в дереве иерарихии
    
    void traverse  (EntityVisitor*,Traverse = TRAVERSE_TOP_TO_BOTTOM); //иерархический обход дерева объектов
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Положение в пространстве
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void translate (const vec3f&); 
    void rotate    (const quatf&);
    void rotate    (float angle_in_degrees,const vec3f& axis);
    void rotate    (float tangent,float yaw,float roll);
    void scale     (const vec3f&);
    void lookat    (const vec3f& from,const vec3f& to); //auto vector up calculations
    void lookat    (const vec3f& from,const vec3f& to,const vec3f& up);
    void identity  ();
    void transform (const mat4f&);
    
    const mat4f& GetLocalTM  ();
    const mat4f& GetWorldTM  ();
    const mat4f  GetObjectTM (Entity* object); //возвращение матрицы положения объекта    
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с центром (pivot)
///////////////////////////////////////////////////////////////////////////////////////////////////        
    Entity* pivot ();
        
///////////////////////////////////////////////////////////////////////////////////////////////////
///Выделение
///////////////////////////////////////////////////////////////////////////////////////////////////            
    void select     (EntitySelect = ENTITY_GROUP_SELECT); //toogle
    bool IsSelected () { return IsEnabled (ENTITY_SELECT); }
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Wire color
///////////////////////////////////////////////////////////////////////////////////////////////////
    void         SetWireColor (const vec3f& color);
    const vec3f& GetWireColor ();    
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Полное имя атрибута
///////////////////////////////////////////////////////////////////////////////////////////////////    
    const char* property (const char* name); //return full property name (danger to use!)    

///////////////////////////////////////////////////////////////////////////////////////////////////
///Присоединение выражений (математических формул) к параметрам
///////////////////////////////////////////////////////////////////////////////////////////////////        
    void        SetExpression (const char* property_name,const char* expression);
    const char* GetExpression (const char* property_name);
    void        RemoveDependencies (); //удаление зависимостей от выражений
    
  protected:
    Entity  (Scene* = NULL);
    virtual ~Entity ();    
    
    virtual void visit (EntityVisitor*);    
    
    void OnModify ();            
    
    virtual void RegisterVars ();
    virtual void UnregisterVars ();    

  private:            
    void _RegisterVars ();
    void _UnregisterVars ();
    
    void OnDelete ();
    void OnCreate ();
    void OnSelect ();
        
  private:
    struct Impl;
    Impl* impl;     
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Виды проекций
///////////////////////////////////////////////////////////////////////////////////////////////////
enum ProjType
{
  CAMERA_PROJ_ORTHO,        //ортогональная
  CAMERA_PROJ_ISOMETRY,     //изометрия
  CAMERA_PROJ_DIMETRY,      //диметрия
  CAMERA_PROJ_TRIMETRY,     //триметрия
  CAMERA_PROJ_CABINET,      //кабинетная
  CAMERA_PROJ_FREE,         //свободная
  CAMERA_PROJ_PERSPECTIVE,  //одноточечная перспективная (базовая)
  CAMERA_PROJ_PERSPECTIVE_SPECIAL //специальная перспективная проекция
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Виды проекций
///////////////////////////////////////////////////////////////////////////////////////////////////
struct ProjParams
{
  ProjType type;                                  //вид проекции
  float    left, right, top, bottom, znear, zfar; //параметры плоскостей отсечения
  float    alpha, beta, gamma;                    //углы для диметрии, триметрии и т.д.
  vec3f    distance;                              //координаты точек на осях для перспективных проекций (устарело)
  vec3f    point [3];                             //координаты точек для перспективной проекции
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Камера
///////////////////////////////////////////////////////////////////////////////////////////////////
class Camera: public Entity
{
  friend class Scene;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Проекции
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetPerspective  (float fov,float near_clip,float far_clip);
    void SetPerspective  (float fov,float near_clip,float far_clip,const vec3f& a,const vec3f& b,const vec3f& c); 
    void SetOrtho        (float left,float right,float top,float bottom,float near_clip,float far_clip);
    void SetIsometry     (float left,float right,float top,float bottom,float near_clip,float far_clip);
    void SetDimetry      (float left,float right,float top,float bottom,float near_clip,float far_clip,float angle1,float angle2);
    void SetTrimetry     (float left,float right,float top,float bottom,float near_clip,float far_clip,float angle1,float angle2);
    void SetCabinet      (float left,float right,float top,float bottom,float near_clip,float far_clip);
    void SetFree         (float left,float right,float top,float bottom,float near_clip,float far_clip);        
    
    const mat4f& GetProjTM ();

    ProjType          GetProjType   (); //вид проекции        
    const ProjParams& GetProjParams (); //дополнительные параметры проекции

    vec3f ProjectWorldPoint (const vec3f&); //получение координат в единичном кубе точки по мировым координатам

///////////////////////////////////////////////////////////////////////////////////////////////////
///Управление
///////////////////////////////////////////////////////////////////////////////////////////////////          
    void forward (float step=1.0f);
    void back    (float step=1.0f);
    void left    (float step=1.0f);
    void right   (float step=1.0f);
    void pitch   (float angle=5.0f);
    void yaw     (float angle=5.0f);
    void roll    (float angle=5.0f);
    
  protected:
    Camera  ();
    ~Camera ();
    
    void visit (EntityVisitor*);    
    
    void RegisterVars ();
    void UnregisterVars ();
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип источника
///////////////////////////////////////////////////////////////////////////////////////////////////        
enum LightType
{
  LIGHT_POINT, //точечный источник
  LIGHT_SPOT,  //локальный направленный источник
  LIGHT_DIRECT //бесконечно удалённый направленный источник
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип цвета источника
///////////////////////////////////////////////////////////////////////////////////////////////////        
enum LightColor
{
  LIGHT_AMBIENT_COLOR,  //поглощённая состовляющая
  LIGHT_DIFFUSE_COLOR,  //рассеяная состовляющая
  LIGHT_SPECULAR_COLOR, //отражённая состовляющая
  
  LIGHT_COLOR_NUM
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Источник света
///////////////////////////////////////////////////////////////////////////////////////////////////        
class Light: public Entity
{
  friend class Scene;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Включение / выключение источника
///////////////////////////////////////////////////////////////////////////////////////////////////            
    void on    ();
    void off   ();
    bool state ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Базовые параметры источника света
///////////////////////////////////////////////////////////////////////////////////////////////////          
    void      SetLightType (LightType type);
    LightType GetLightType ();

///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка типа источника (изменяет положение локальной системы координат)
///////////////////////////////////////////////////////////////////////////////////////////////////
    void SetPointLight  (const vec3f& pos);
    void SetSpotLight   (const vec3f& pos,const vec3f& dir,float angle=45.0f);
    void SetDirectLight (const vec3f& dir);

///////////////////////////////////////////////////////////////////////////////////////////////////
///Цвет
///////////////////////////////////////////////////////////////////////////////////////////////////
    void         SetLightColor (LightColor type,const vec3f& color);
    const vec3f& GetLightColor (LightColor type);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Дополнительные настройки Spot light
///////////////////////////////////////////////////////////////////////////////////////////////////
    void  SetSpotAngle    (float angle);
    void  SetSpotExponent (float exponent);    
    float GetSpotAngle    ();
    float GetSpotExponent ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Радиус освещения
///////////////////////////////////////////////////////////////////////////////////////////////////            
    void  SetInnerRadius (float radius);
    float GetInnerRadius ();
        
  protected:
    Light  ();
    ~Light ();  
    
    void visit (EntityVisitor*);    
   
    void RegisterVars   ();
    void UnregisterVars ();
      
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тип параметрической модели
///////////////////////////////////////////////////////////////////////////////////////////////////        
enum ParamModelType
{
  MODEL_UNKNOWN,
  MODEL_BOX,
  MODEL_HALF_SPHERE,  
  MODEL_SPHERE,
  MODEL_CONE,
  MODEL_HALF_CONE,
  MODEL_CYLINDER,
  MODEL_HALF_CYLINDER,
  MODEL_TETRAHEDRON,
  MODEL_HEXAHEDRON,
  MODEL_OCTAHEDRON,
  MODEL_DODECAHEDRON,
  MODEL_ICOSAHEDRON,
  MODEL_HALF_TORUS,
  MODEL_TORUS,
    
  MODEL_NUM      
};

class Surface;
class Material;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Унифицированная параметрическая модель
///////////////////////////////////////////////////////////////////////////////////////////////////        
class ParamModel: public Entity
{
  friend class Scene;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / взятие типа модели
///////////////////////////////////////////////////////////////////////////////////////////////////            
    void           SetModelType (ParamModelType type);
    ParamModelType GetModelType ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка / взятие значений параметров
///////////////////////////////////////////////////////////////////////////////////////////////////          
    void  SetParam (const char* name,float value);
    float GetParam (const char* name);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Поверхность и материал
///////////////////////////////////////////////////////////////////////////////////////////////////              
    Surface*  GetSurface ();
    Material& GetMaterial ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Ограничивающий ящик
///////////////////////////////////////////////////////////////////////////////////////////////////                  
    AABB GetLocalAABB ();
    AABB GetWorldAABB ();
    
  private:
    ParamModel  ();
    ~ParamModel ();
    
    void visit (EntityVisitor*);      
    
    void RegisterVars   ();
    void UnregisterVars ();    
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вид хэлпера
///////////////////////////////////////////////////////////////////////////////////////////////////
enum HelperId  
{
  HELPER_POINT,  //точка
  HELPER_ARROW,  //стрелка
  HELPER_RECT,   //прямоугольник
  HELPER_AXES,   //оси координат
  HELPER_ARC,    //дуга
  HELPER_SECTOR, //сектор
  HELPER_CIRCLE, //окружность
  HELPER_LINE,   //линия
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Хэлпер
///////////////////////////////////////////////////////////////////////////////////////////////////
class HelperEntity: public Entity
{
  friend class Scene;
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Установка вида хэлпера
///////////////////////////////////////////////////////////////////////////////////////////////////  
    void SetPoint  (const vec3f& pos = 0.0f);
    void SetAxes   (const vec3f& pos = 0.0f);    
    void SetArrow  (const vec3f& from = 0.0f,const vec3f& to = vec3f (0,0,1));
    void SetLine   (const vec3f& from = 0.0f,const vec3f& to = vec3f (0,0,1));
    void SetArc    (const vec3f& pos = 0.0f,const vec3f dir = vec3f (0.0f,0.0f,1.0f),const vec3f up = (0.0f,1.0f,0.0f));
    void SetSector (const vec3f& pos = 0.0f,const vec3f dir = vec3f (0.0f,0.0f,1.0f),const vec3f up = (0.0f,1.0f,0.0f),const float angle = 180);
    void SetCircle (const vec3f& pos = 0.0f,const vec3f dir = vec3f (0.0f,0.0f,1.0f),const vec3f up = (0.0f,1.0f,0.0f));
    void SetRect   (const vec3f& center = 0.0f,const vec3f& dir = vec3f (0,0,1),const vec3f& size = 1.0f);
    
    HelperId GetHelperId ();
    float    GetHelperAngle ();
    void     SetHelperAngle (const float& angle);
    
  private:
    HelperEntity ();
    ~HelperEntity ();    
    
    void visit (EntityVisitor*);
  
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Ландшафтная модель
///////////////////////////////////////////////////////////////////////////////////////////////////
class LandscapeModel: public Entity, public Landscape
{
  friend class Scene;
  private:
    LandscapeModel ();
    ~LandscapeModel ();
    
    void visit (EntityVisitor*);
    
  private:
    struct Impl;
    Impl* impl;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Слушатель сцены
///////////////////////////////////////////////////////////////////////////////////////////////////        
class SceneListener
{
  public:  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Вызовы на создание объектов
///////////////////////////////////////////////////////////////////////////////////////////////////          
    virtual void OnCreate (Entity*)       {}
    virtual void OnCreate (Light*)        {}
    virtual void OnCreate (Camera*)       {}
    virtual void OnCreate (ParamModel*)   {}
    virtual void OnCreate (HelperEntity*) {}

///////////////////////////////////////////////////////////////////////////////////////////////////
///Вызовы на удаление обектов
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void OnDelete (Entity*)       {}
    virtual void OnDelete (Light*)        {}
    virtual void OnDelete (Camera*)       {}
    virtual void OnDelete (ParamModel*)   {}
    virtual void OnDelete (HelperEntity*) {}
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Вызовы на обновление объектов
///////////////////////////////////////////////////////////////////////////////////////////////////
    virtual void OnModify (Entity*)       {}
    virtual void OnModify (Light*)        {}
    virtual void OnModify (Camera*)       {}
    virtual void OnModify (ParamModel*)   {}
    virtual void OnModify (HelperEntity*) {}
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Вызовы на выделение объекта
///////////////////////////////////////////////////////////////////////////////////////////////////    
    virtual void OnSelect (Entity*) {}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Сцена
///////////////////////////////////////////////////////////////////////////////////////////////////        
class Scene
{
  friend class Entity;
  public:        
            Scene  (bool register_vars=false); //register_vars - необходимость регистрации именованных переменных
            Scene  (const char* file_name,bool register_vars=false);
    virtual ~Scene ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Корневой объект
///////////////////////////////////////////////////////////////////////////////////////////////////
    Entity* root (); 
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Сброс сцены
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void reset ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Создание объектов
///////////////////////////////////////////////////////////////////////////////////////////////////                
    Entity*         CreateEntity ();
    Light*          CreateLight  ();
    Camera*         CreateCamera ();
    ParamModel*     CreateModel  ();
    HelperEntity*   CreateHelper ();
    LandscapeModel* CreateLandscape ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Выделенные объекты
///////////////////////////////////////////////////////////////////////////////////////////////////
    const EntityList& GetSelection   ();
    void              ClearSelection ();
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Прослушивание сцены
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void RegisterListener   (SceneListener*);
    void UnregisterListener (SceneListener*);
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Загрузка / сохранение сцены
///////////////////////////////////////////////////////////////////////////////////////////////////        
     bool save (const char* file_name);
     bool load (const char* file_name);
    
  private:
    void select (Entity*,bool);
    
    void OnCreate (Entity*);
    void OnModify (Entity*);
    void OnDelete (Entity*);
    void OnSelect (Entity*);
    
    template <class T> T* CreateObject ();
      
  private:
    struct Impl;
    Impl* impl;
};

#endif
