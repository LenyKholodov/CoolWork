#ifndef __COMMONLIB_PARSER__
#define __COMMONLIB_PARSER__

#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

///////////////////////////////////////////////////////////////////////////////////////////////////
///Узел синтаксического дерева
///////////////////////////////////////////////////////////////////////////////////////////////////
class ParseNode
{
  public:
///////////////////////////////////////////////////////////////////////////////////////////////////
///Итерация
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseNode* first () const;
    ParseNode* next  () const;
    ParseNode* first (const char*) const;
    ParseNode* next  (const char*) const;

///////////////////////////////////////////////////////////////////////////////////////////////////
///Тэг
///////////////////////////////////////////////////////////////////////////////////////////////////
    const char* tag   () const;
    bool        test  (const char* name) const; //проверяет совпадение имени

///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с аргументами
///////////////////////////////////////////////////////////////////////////////////////////////////
    size_t       argc () const;
    const char** argv () const;
    const char*  arg  (size_t i) const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Протоколирование ошибок
///////////////////////////////////////////////////////////////////////////////////////////////////    
    void error    (const char*,...);
    void warning  (const char*,...);
    void verror   (const char*,va_list);
    void vwarning (const char*,va_list);

  private:
    ParseNode ();
    ~ParseNode ();
    
  private:  
    char data [1];
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Результат разбора
///////////////////////////////////////////////////////////////////////////////////////////////////          
enum ParseResult
{
  PARSE_OK = 0,   //ошибок и предупреждений нет
  PARSE_WARNINGS, //есть предуепреждения
  PARSE_ERRORS    //есть ошибки
};

///////////////////////////////////////////////////////////////////////////////////////////////////
///Парсер
///////////////////////////////////////////////////////////////////////////////////////////////////          
class Parser
{
  public:
    Parser  (const char* file_name,const char* format=NULL);  //NULL - auto detect
    Parser  (const char* buf,size_t len,const char* format=NULL);
    ~Parser ();
  
///////////////////////////////////////////////////////////////////////////////////////////////////
///Корень дерева разбора
///////////////////////////////////////////////////////////////////////////////////////////////////
    ParseNode* root () const;
    
///////////////////////////////////////////////////////////////////////////////////////////////////
///Работа с протоколом ошибок
///////////////////////////////////////////////////////////////////////////////////////////////////      
    ParseResult status () const; //результат разбора
    const char* log    () const; //возвращает строку с описанием ошибок (разделитель '/n')

  private:
    struct ParseTree* tree;
};

#endif
